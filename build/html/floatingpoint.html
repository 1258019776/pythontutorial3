<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>14. 浮点数算法：争议和限制 &mdash; Python tutorial 3.4.2 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '3.4.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Python tutorial 3.4.2 documentation" href="index.html" />
    <link rel="next" title="15. Appendix" href="appendix.html" />
    <link rel="prev" title="13. 交互式输入行编辑历史回溯" href="interactive.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="appendix.html" title="15. Appendix"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="interactive.html" title="13. 交互式输入行编辑历史回溯"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Python tutorial 3.4.2 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="tut-fp-issues">
<span id="id1"></span><h1>14. 浮点数算法：争议和限制<a class="headerlink" href="#tut-fp-issues" title="Permalink to this headline">¶</a></h1>
<p>浮点数在计算机中表达为二进制（binary）小数。例如：十进制小数:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="mf">0.125</span>
</pre></div>
</div>
<p>是 1/10 + 2/100 + 5/1000 的值，同样二进制小数:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="mf">0.001</span>
</pre></div>
</div>
<p>是 0/2 + 0/4 + 1/8。这两个数值相同。唯一的实质区别是第一个写为十进制小数记法，第二个是二进制。</p>
<p>遗憾的是，大多数十进制小数不能精确的表达二进制小数。</p>
<p>这个问题更早的时候首先在十进制中发现。考虑小数形式的 1/3 ，你可以来个十进制的近似值。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="mf">0.3</span>
</pre></div>
</div>
<p>或者更进一步的,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="mf">0.33</span>
</pre></div>
</div>
<p>或者更进一步的,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="mf">0.333</span>
</pre></div>
</div>
<p>诸如此类。如果你写多少位，这个结果永远不是精确的 1/3 ，但是可以无限接近 1/3 。</p>
<p>同样，无论在二进制中写多少位，十进制数 0.1 都不能精确表达为二进制小数。二进制来表达 1/10 是一个无限循环小数:</p>
<div class="highlight-python"><div class="highlight"><pre>0.0001100110011001100110011001100110011001100110011...
</pre></div>
</div>
<p>在任意无限位数值中中止，你可以得到一个近似。</p>
<p>在一个典型的机器上运行Python，一共有53位的精度来表示一个浮点数，所以当你输入十进制的 <code class="docutils literal"><span class="pre">0.1</span></code> 的时候，看到是一个二进制的小数:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="mf">0.00011001100110011001100110011001100110011001100110011010</span>
</pre></div>
</div>
<p>非常接近，但是不完全等于，1/10。</p>
<p>这是很容易忘记，存储的值是一个近似的原小数，由于浮体的方式，显示在提示符的解释。 Python 中只打印一个小数近似的真实机器所存储的二进制近似的十进制值。如果 Python
要打印存储的二进制近似真实的十进制值0.1，那就要显示:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="mf">0.1</span>
<span class="go">0.1000000000000000055511151231257827021181583404541015625</span>
</pre></div>
</div>
<p>这么多位的数字对大多数人是没有用的，所以 Python 显示一个舍入的值</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span> <span class="o">/</span> <span class="mi">10</span>
<span class="go">0.1</span>
</pre></div>
</div>
<p>只要记住即使打印的结果看上去是精确的1/10，真正存储的值是最近似的二进制小数。</p>
<p>有趣地是，存在许多不同的十进制数共享着相同的近似二进制小数。例如，数字 <code class="docutils literal"><span class="pre">0.1</span></code> 和 <code class="docutils literal"><span class="pre">0.10000000000000001</span></code> 以及 <code class="docutils literal"><span class="pre">0.1000000000000000055511151231257827021181583404541015625</span></code> 都是 <code class="docutils literal"><span class="pre">3602879701896397</span> <span class="pre">/</span> <span class="pre">2</span> <span class="pre">**</span> <span class="pre">55</span></code> 的近似值。因为所有这些十进制数共享相同的近似值，在保持恒等式 <code class="docutils literal"><span class="pre">eval(repr(x))</span> <span class="pre">==</span> <span class="pre">x</span></code> 的同时，显示的可能是它们中的任何一个。</p>
<p>历史上，Python 提示符和内置的 <code class="xref py py-func docutils literal"><span class="pre">repr()</span></code> 函数选择一个 17 位精度的数字，<code class="docutils literal"><span class="pre">0.10000000000000001</span></code>。从 Python 3.1 开始，Python（在大多数系统上）能够从这些数字当中选择最短的一个并简单地显示 <code class="docutils literal"><span class="pre">0.1</span></code>。</p>
<p>注意，这是二进制浮点数的自然性质：它不是 Python 中的一个 bug，也不是你的代码中的 bug。你会看到所有支持硬件浮点数算法的语言都会有这个现象（尽管有些语言默认情况下或者在所有输出模式下可能不会 <em>显示</em> 出差异）。</p>
<p>为了输出更好看，你可能想用字符串格式化来生成固定位数的有效数字:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">format</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="s">&#39;.12g&#39;</span><span class="p">)</span>  <span class="c"># give 12 significant digits</span>
<span class="go">&#39;3.14159265359&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">format</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="s">&#39;.2f&#39;</span><span class="p">)</span>   <span class="c"># give 2 digits after the point</span>
<span class="go">&#39;3.14&#39;</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">repr</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="go">&#39;3.141592653589793&#39;</span>
</pre></div>
</div>
<p>认识到这，在真正意义上，是一种错觉是很重要的：你在简单地舍入真实机器值的 <em>显示</em>。</p>
<p>例如，既然 0.1 不是精确的 1/10，3 个 0.1 的值相加可能也不会得到精确的 0.3:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="o">.</span><span class="mi">1</span> <span class="o">+</span> <span class="o">.</span><span class="mi">1</span> <span class="o">+</span> <span class="o">.</span><span class="mi">1</span> <span class="o">==</span> <span class="o">.</span><span class="mi">3</span>
<span class="go">False</span>
</pre></div>
</div>
<p>另外，既然 0.1 不能更接近 1/10 的精确值而且 0.3 不能更接近 3/10 的精确值，使用 <code class="xref py py-func docutils literal"><span class="pre">round()</span></code> 函数提前舍入也没有帮助:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">round</span><span class="p">(</span><span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nb">round</span><span class="p">(</span><span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nb">round</span><span class="p">(</span><span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">round</span><span class="p">(</span><span class="o">.</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>虽然这些数字不可能再更接近它们想要的精确值，<code class="xref py py-func docutils literal"><span class="pre">round()</span></code> 函数可以用于在计算之后进行舍入，这样的话不精确的结果就可以和另外一个相比较了:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">round</span><span class="p">(</span><span class="o">.</span><span class="mi">1</span> <span class="o">+</span> <span class="o">.</span><span class="mi">1</span> <span class="o">+</span> <span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="nb">round</span><span class="p">(</span><span class="o">.</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>二进制浮点数计算有很多这样意想不到的结果。“0.1”的问题在下面&#8221;误差的表示&#8221;一节中有准确详细的解释。更完整的常见怪异现象请参见 <a class="reference external" href="http://www.lahey.com/float.htm">浮点数的危险</a>。</p>
<p>最后我要说，“没有简单的答案”。也不要过分小心浮点数！Python 浮点数计算中的误差源之于浮点数硬件，大多数机器上每次计算误差不超过 2**53 分之一。对于大多数任务这已经足够了，但是你要在心中记住这不是十进制算法，每个浮点数计算可能会带来一个新的舍入错误。</p>
<p>虽然确实有问题存在，对于大多数平常的浮点数运算，你只要简单地将最终显示的结果舍入到你期望的十进制位数，你就会得到你期望的最终结果。<code class="xref py py-func docutils literal"><span class="pre">str()</span></code> 通常已经足够用了，对于更好的控制可以参阅 <a class="reference external" href="http://python.usyiyi.cn/python_341/library/string.html#formatstrings">格式化字符串语法</a> 中 <code class="xref py py-meth docutils literal"><span class="pre">str.format()</span></code> 方法的格式说明符。</p>
<p>对于需要精确十进制表示的情况，可以尝试使用 <code class="xref py py-mod docutils literal"><span class="pre">decimal</span></code> 模块，它实现的十进制运算适合会计方面的应用和高精度要求的应用。</p>
<p><code class="xref py py-mod docutils literal"><span class="pre">fractions</span></code> 模块支持另外一种形式的运算，它实现的运算基于有理数（因此像1/3这样的数字可以精确地表示）。</p>
<p>如果你是浮点数操作的重度使用者，你应该看一下由 SciPy 项目提供的 Numerical Python 包和其它用于数学和统计学的包。参看 &lt;<a class="reference external" href="http://scipy.org">http://scipy.org</a>&gt;。</p>
<p>当你真的 <em>真</em> 想要知道浮点数精确值的时候，Python 提供这样的工具可以帮助你。<code class="xref py py-meth docutils literal"><span class="pre">float.as_integer_ratio()</span></code> 方法以分数的形式表示一个浮点数的值:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="mf">3.14159</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">as_integer_ratio</span><span class="p">()</span>
<span class="go">(3537115888337719, 1125899906842624)</span>
</pre></div>
</div>
<p>因为比值是精确的，它可以用来无损地重新生成初始值:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">==</span> <span class="mi">3537115888337719</span> <span class="o">/</span> <span class="mi">1125899906842624</span>
<span class="go">True</span>
</pre></div>
</div>
<p><code class="xref py py-meth docutils literal"><span class="pre">float.hex()</span></code> 方法以十六进制表示浮点数，给出的同样是计算机存储的精确值:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">hex</span><span class="p">()</span>
<span class="go">&#39;0x1.921f9f01b866ep+1&#39;</span>
</pre></div>
</div>
<p>精确的十六进制表示可以用来准确地重新构建浮点数:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">==</span> <span class="nb">float</span><span class="o">.</span><span class="n">fromhex</span><span class="p">(</span><span class="s">&#39;0x1.921f9f01b866ep+1&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>因为可以精确表示，所以可以用在不同版本的 Python（与平台相关）之间可靠地移植数据以及与支持同样格式的其它语言（例如 Java 和 C99）交换数据。</p>
<p>另外一个有用的工具是 <code class="xref py py-func docutils literal"><span class="pre">math.fsum()</span></code> 函数，它帮助求和过程中减少精度的损失。当数值在不停地相加的时候，它会跟踪“丢弃的数字”。这可以给总体的准确度带来不同，以至于错误不会累积到影响最终结果的点:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">sum</span><span class="p">([</span><span class="mf">0.1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="mf">1.0</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">math</span><span class="o">.</span><span class="n">fsum</span><span class="p">([</span><span class="mf">0.1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span> <span class="o">==</span> <span class="mf">1.0</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="section" id="tut-fp-error">
<span id="id4"></span><h2>14.1. 表达错误<a class="headerlink" href="#tut-fp-error" title="Permalink to this headline">¶</a></h2>
<p>这一节详细说明 “0.1” 示例，教你怎样自己去精确的分析此类案例。假设这里你已经对浮点数表示有基本的了解。</p>
<p><em class="dfn">Representation error</em>  提及事实上有些（实际是大多数）十进制小数不能精确的表示为二进制小数。这是 Python （或 Perl，C，C++，Java，Fortran 以及其它很多）语言往往不能按你期待的样子显示十进制数值的根本原因:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="mf">0.1</span> <span class="o">+</span> <span class="mf">0.2</span>
<span class="go">0.30000000000000004</span>
</pre></div>
</div>
<p>这 是为什么？ 1/10 不能精确的表示为二进制小数。大多数今天的机器（2000年十一月）使用 IEEE-754 浮点数算法，大多数平台上 Python 将浮点数映射为 IEEE-754 “双精度浮点数”。754 双精度包含 53 位精度，所以计算机努力将输入的 0.1 转为 J/2**N 最接近的二进制小数。<em>J</em> 是一个 53 位的整数。改写:</p>
<div class="highlight-python"><div class="highlight"><pre>1 / 10 ~= J / (2**N)
</pre></div>
</div>
<p>为:</p>
<div class="highlight-python"><div class="highlight"><pre>J ~= 2**N / 10
</pre></div>
</div>
<p>J 重现时正是 53 位（是 &gt;= 2**52 而非 &lt; 2**53 ）， N 的最佳值是 56:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="mi">2</span><span class="o">**</span><span class="mi">52</span>
<span class="go">4503599627370496</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">2</span><span class="o">**</span><span class="mi">53</span>
<span class="go">9007199254740992</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">2</span><span class="o">**</span><span class="mi">56</span><span class="o">/</span><span class="mi">10</span>
<span class="go">7205759403792793</span>
</pre></div>
</div>
<p>因此，56 是保持 J 精度的唯一 N 值。 J 最好的近似值是整除的商:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">56</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span>
<span class="go">6</span>
</pre></div>
</div>
<p>因为余数大于 10 的一半，最好的近似是取上界:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">q</span><span class="o">+</span><span class="mi">1</span>
<span class="go">7205759403792794</span>
</pre></div>
</div>
<p>因此在 754 双精度中 1/10 最好的近似值是是 2**56，或:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="mi">7205759403792794</span> <span class="o">/</span> <span class="mi">72057594037927936</span>
</pre></div>
</div>
<p>要注意因为我们向上舍入，它其实比 1/10 稍大一点点。如果我们没有向上舍入，它会比 1/10 稍小一点。但是没办法让它 恰好 是 1/10！</p>
<p>所以计算机永远也不 “知道” 1/10：它遇到上面这个小数，给出它所能得到的最佳的 754 双精度实数:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="o">.</span><span class="mi">1</span> <span class="o">*</span> <span class="mi">2</span><span class="o">**</span><span class="mi">55</span>
<span class="go">7205759403792794.0</span>
</pre></div>
</div>
<p>如果我们把这小数乘以 10**55，我们可以看到其55位十进制数的值:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="mi">3602879701896397</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">**</span> <span class="mi">55</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">55</span>
<span class="go">1000000000000000055511151231257827021181583404541015625</span>
</pre></div>
</div>
<p>这表示存储在计算机中的实际值近似等于十进制值 0.1000000000000000055511151231257827021181583404541015625。许多语言（包括旧版本的Python）会把结果舍入到17位有效数字，而不是显示全部的十进制值:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">format</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="s">&#39;.17f&#39;</span><span class="p">)</span>
<span class="go">&#39;0.10000000000000001&#39;</span>
</pre></div>
</div>
<p><code class="xref py py-mod docutils literal"><span class="pre">fractions</span></code> 和 <code class="xref py py-mod docutils literal"><span class="pre">decimal</span></code> 模块使得这些计算很简单:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">decimal</span> <span class="kn">import</span> <span class="n">Decimal</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">fractions</span> <span class="kn">import</span> <span class="n">Fraction</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">Fraction</span><span class="o">.</span><span class="n">from_float</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
<span class="go">Fraction(3602879701896397, 36028797018963968)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span><span class="o">.</span><span class="n">as_integer_ratio</span><span class="p">()</span>
<span class="go">(3602879701896397, 36028797018963968)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">Decimal</span><span class="o">.</span><span class="n">from_float</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
<span class="go">Decimal(&#39;0.1000000000000000055511151231257827021181583404541015625&#39;)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">format</span><span class="p">(</span><span class="n">Decimal</span><span class="o">.</span><span class="n">from_float</span><span class="p">(</span><span class="mf">0.1</span><span class="p">),</span> <span class="s">&#39;.17&#39;</span><span class="p">)</span>
<span class="go">&#39;0.10000000000000001&#39;</span>
</pre></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">14. 浮点数算法：争议和限制</a><ul>
<li><a class="reference internal" href="#tut-fp-error">14.1. 表达错误</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="interactive.html"
                        title="previous chapter">13. 交互式输入行编辑历史回溯</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="appendix.html"
                        title="next chapter">15. Appendix</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/floatingpoint.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>

<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 首页侧边 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:200px;height:200px"
     data-ad-client="ca-pub-3421553373953599"
     data-ad-slot="3551838308"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="appendix.html" title="15. Appendix"
             >next</a> |</li>
        <li class="right" >
          <a href="interactive.html" title="13. 交互式输入行编辑历史回溯"
             >previous</a> |</li>
        <li><a href="index.html">Python tutorial 3.4.2 documentation</a> &raquo;</li> 
      </ul>
    </div>
<div class="footer">
    <p>
 © Copyright Translate by march.liu, Reorganize by D.D 2013. Created using
<a href="http://sphinx.pocoo.org/">Sphinx</a>
1.2. 
</p>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?9adc7a1c86496c8e2bc61c4f8fc92d30";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<p><a href="http://www.miitbeian.gov.cn/">京ICP备14002119号-1</a></p>
<hr/>


<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- pythondoc 首页下方 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:970px;height:90px"
     data-ad-client="ca-pub-3421553373953599"
     data-ad-slot="6985889234"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>


</div>




  </body>
</html>